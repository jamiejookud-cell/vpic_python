Code dump created on 15:24:10 - 15:24:13 2025/12/25 (UTC+07)
Code files:

────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────

═══════ C:/DEV/local_repo/vpic_python/code_python/scripts/config/parameters.py ═══════

# ------------------------------ Simulation Parameters ------------------------------ #
nx: int = 8192                 # grid cell x (length code)
nz: int = 1024                 # grid cell z (length code)

dt_wpe: float = 6.363961e-02   # electron time resolution      [time (wpe-1) / time code]
dt_wci: float = 1.272792e-04   # ion cyclotron time resolution [time (wci-1) / time code]

dx_de: float = 1.000000e-01    # length x resolution           [length (de) / length code]
dz_de: float = 1.000000e-01    # length z resolution           [length (de) / length code]

timestep_interval: int = 78    # (time code)
# ------------------------------------------------------------------------------------ #

────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────





────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────

═══════ C:/DEV/local_repo/vpic_python/code_python/scripts/setup/timestep_setup.py ═══════

# ------------------------------------- #
#      Timestep range configuration     #
# ------------------------------------- #
TIMESTEP_RANGE: tuple[int, int] = (64584, 142506) # 64584 (time that shock reaches steady state), 142506 (maximum snapshot)
SPECIFIC_TIMESTEP: int          = -1
SKIP_TO_FOLDER: int             = -1

# TIMESTEP_RANGE:
# Use -1 to indicate 'no limit' on either side.
# Examples:
# (-1, -1)    -> from T.start to T.end
# (-1, 10000) -> from T.start to T.10000
# (10000, -1) -> from T.10000 to T.end

# SPECIFIC_TIMESTEP:
# equivalent to TIMESTEP_RANGE = (SPECIFIC_TIMESTEP, SPECIFIC_TIMESTEP)

# SKIP_TO_FOLDER:
# T.6000 T.6001 T.6002 .... T.6020
# Skip folders up to next index. Use -1 to disable.
# Examples: [T.0, T.100, T.200, T.300, T.400, T.500, ...]
# SKIP_TO_FOLDER = 2
# Output >>> [T.0, T.200, T.400, ...]
# ------------------------------------------------------------------------------------ #

────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────





────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────

═══════ C:/DEV/local_repo/vpic_python/code_python/scripts/setup/calculation_setup.py ═══════

# CONST
V_SH: float = 0.05609 # [length (de) / time (wpe-1)]
# This 0.05609 is the speed of shock moving from right to left.

# -------------------------------- Calculating Setup --------------------------------- #
IS_CALCULATING_SHOCK_SPEED: bool            = False
# IS_CALCULATING_SHOCK_VELOCITY:
# Compute shock speed by tracking rho_i vs timestep. Output is the V_SH value and the tracking graph.
# *** NOTE: Be sure not to include T.0 or T.XXXXXX that shock hit the boundary in the TIMESTEP_RANGE. ***

box_frame = [-2304, 0, 3072, 1024] # [x0, y0, length, height]
IS_CALCULATING_LORENTZ_TRANSFORMATION: bool = True
target_velocity: float = V_SH

ENABLE_ADVANCED_CALCULATION: bool           = True

IS_EXPORT_DATA_TO_CSV: bool                 = True
# ------------------------------------------------------------------------------------ #

────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────





────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────

═══════ C:/DEV/local_repo/vpic_python/code_python/scripts/preprocessing/get_hdf5_data.py ═══════

"""
NOTE: Please ensure that you have tested all folders by using _check_corrupted_hdf5_folders.py
"""

import numpy as np
import os
import h5py
import natsort # Sort folders
from code_python.scripts.config.folder_paths import SHOCK_DATA_PATH
from code_python.scripts.config.parameters import nx, nz
from code_python.scripts.setup.timestep_setup import  TIMESTEP_RANGE, SPECIFIC_TIMESTEP, SKIP_TO_FOLDER
from code_python.scripts.setup.calculation_setup import box_frame
from code_python.scripts.dumping_backup_python_output import dump_process

# ---------------------------------------- #
#             Pre-allocate Data            #
# ---------------------------------------- #
simulation_frame_zero_array = np.zeros((nx, nz))

# hydro electron hdf5 data
jx_e = simulation_frame_zero_array.copy()
jy_e = simulation_frame_zero_array.copy()
jz_e = simulation_frame_zero_array.copy()
ke_e = simulation_frame_zero_array.copy()
px_e = simulation_frame_zero_array.copy()
py_e = simulation_frame_zero_array.copy()
pz_e = simulation_frame_zero_array.copy()
rho_e = simulation_frame_zero_array.copy()
txx_e = simulation_frame_zero_array.copy()
txy_e = simulation_frame_zero_array.copy()
tyy_e = simulation_frame_zero_array.copy()
tyz_e = simulation_frame_zero_array.copy()
tzx_e = simulation_frame_zero_array.copy()
tzz_e = simulation_frame_zero_array.copy()

# hydro ion hdf5 data
jx_i = simulation_frame_zero_array.copy()
jy_i = simulation_frame_zero_array.copy()
jz_i = simulation_frame_zero_array.copy()
ke_i = simulation_frame_zero_array.copy()
px_i = simulation_frame_zero_array.copy()
py_i = simulation_frame_zero_array.copy()
pz_i = simulation_frame_zero_array.copy()
rho_i = simulation_frame_zero_array.copy()
txx_i = simulation_frame_zero_array.copy()
txy_i = simulation_frame_zero_array.copy()
tyy_i = simulation_frame_zero_array.copy()
tyz_i = simulation_frame_zero_array.copy()
tzx_i = simulation_frame_zero_array.copy()
tzz_i = simulation_frame_zero_array.copy()

# electric and magnetic fields hdf5 data
cex = simulation_frame_zero_array.copy()
cey = simulation_frame_zero_array.copy()
cez = simulation_frame_zero_array.copy()
cbx = simulation_frame_zero_array.copy()
cby = simulation_frame_zero_array.copy()
cbz = simulation_frame_zero_array.copy()

# NOTE: prime is denoted Lorentz frame
# derived data used in Lorentz transformation
box_frame_zero_array = np.zeros((box_frame[2], box_frame[3]))

rho_i_prime = box_frame_zero_array.copy()
jx_i_prime = box_frame_zero_array.copy()
jy_i_prime = box_frame_zero_array.copy()
jz_i_prime = box_frame_zero_array.copy()

rho_e_prime = box_frame_zero_array.copy()
jx_e_prime = box_frame_zero_array.copy()
jy_e_prime = box_frame_zero_array.copy()
jz_e_prime = box_frame_zero_array.copy()

cex_prime = box_frame_zero_array.copy()
cey_prime = box_frame_zero_array.copy()
cez_prime = box_frame_zero_array.copy()

cbx_prime = box_frame_zero_array.copy()
cby_prime = box_frame_zero_array.copy()
cbz_prime = box_frame_zero_array.copy()

# ---------------------------------------- #
#         Folder Preprocessing             #
# ---------------------------------------- #
folders = []
_folders = []
__folders = []

# If SPECIFIC_TIMESTEP is applied
if SPECIFIC_TIMESTEP != -1:
    folders = [f"T.{SPECIFIC_TIMESTEP}"]
else:
    # Output example >>> ['T.0', 'T.3100', ...]
    # List all timestep folders from hydro_hdf5/
    __folders = natsort.natsorted(os.listdir(f"{SHOCK_DATA_PATH}/hydro_hdf5"))

    # Select based on timestep range
    for f in __folders:
        file_timestep = int(f[2:])
        t_min, t_max = TIMESTEP_RANGE
        if (t_min == -1 and t_max == -1) or \
           (t_min != -1 and t_min <= file_timestep <= t_max) or \
           (t_min == -1 and file_timestep <= t_max) or \
           (t_max == -1 and file_timestep >= t_min):
            _folders.append(f)

    # Apply file skipping
    folders = [f for i, f in enumerate(_folders) if i % SKIP_TO_FOLDER == 0] \
        if SKIP_TO_FOLDER > 1 else _folders
folder_count = len(folders)
dump_process(f"folder count = {folder_count}")

# ---------------------------------------- #
#        HDF5 Data Reader Function         #
# ---------------------------------------- #
# NOTE: Code runs very fast if we import only necessary files
def read_timestep(shock_folder: str) -> dict:
    """
    continuity equation and energy-momentum tensor
    //  float jx, jy, jz, rho; // Current and charge density => <q v_i f>, <q f>
    //  float px, py, pz, ke;  // Momentum and K.E. density  => <p_i f>, <m c^2 (gamma-1) f>
    //  float txx, tyy, tzz;   // Stress diagonal            => <p_i v_j f>, i==j
    //  float tyz, tzx, txy;   // Stress off-diagonal        => <p_i v_j f>, i!=j
    """
    current_timestep = int(shock_folder[2:])

    electron_file_path_location = (f'{SHOCK_DATA_PATH}/hydro_hdf5/T.{current_timestep}'
                                   f'/hydro_electron_{current_timestep}.h5')
    ion_file_path_location = (f'{SHOCK_DATA_PATH}/hydro_hdf5/T.{current_timestep}'
                              f'/hydro_ion_{current_timestep}.h5')

    # Importing electron file data, subscript with 'e'
    with h5py.File(electron_file_path_location, 'r') as hdf5_r:
        jx_e = np.squeeze(hdf5_r[f'/Timestep_{current_timestep}/jx'][:])
        jy_e = np.squeeze(hdf5_r[f'/Timestep_{current_timestep}/jy'][:])
        jz_e = np.squeeze(hdf5_r[f'/Timestep_{current_timestep}/jz'][:])
        ke_e = np.squeeze(hdf5_r[f'/Timestep_{current_timestep}/ke'][:])
        px_e = np.squeeze(hdf5_r[f'/Timestep_{current_timestep}/px'][:])
        py_e = np.squeeze(hdf5_r[f'/Timestep_{current_timestep}/py'][:])
        pz_e = np.squeeze(hdf5_r[f'/Timestep_{current_timestep}/pz'][:])
        rho_e = np.squeeze(hdf5_r[f'/Timestep_{current_timestep}/rho'][:])
        txx_e = np.squeeze(hdf5_r[f'/Timestep_{current_timestep}/txx'][:])
        txy_e = np.squeeze(hdf5_r[f'/Timestep_{current_timestep}/txy'][:])
        tyy_e = np.squeeze(hdf5_r[f'/Timestep_{current_timestep}/tyy'][:])
        tyz_e = np.squeeze(hdf5_r[f'/Timestep_{current_timestep}/tyz'][:])
        tzx_e = np.squeeze(hdf5_r[f'/Timestep_{current_timestep}/tzx'][:])
        tzz_e = np.squeeze(hdf5_r[f'/Timestep_{current_timestep}/tzz'][:])

    # Importing ion file data, subscript with 'i'
    with h5py.File(ion_file_path_location, 'r') as hdf5_r:
        jx_i = np.squeeze(hdf5_r[f'/Timestep_{current_timestep}/jx'][:])
        jy_i = np.squeeze(hdf5_r[f'/Timestep_{current_timestep}/jy'][:])
        jz_i = np.squeeze(hdf5_r[f'/Timestep_{current_timestep}/jz'][:])
        ke_i = np.squeeze(hdf5_r[f'/Timestep_{current_timestep}/ke'][:])
        px_i = np.squeeze(hdf5_r[f'/Timestep_{current_timestep}/px'][:])
        py_i = np.squeeze(hdf5_r[f'/Timestep_{current_timestep}/py'][:])
        pz_i = np.squeeze(hdf5_r[f'/Timestep_{current_timestep}/pz'][:])
        rho_i = np.squeeze(hdf5_r[f'/Timestep_{current_timestep}/rho'][:])
        txx_i = np.squeeze(hdf5_r[f'/Timestep_{current_timestep}/txx'][:])
        txy_i = np.squeeze(hdf5_r[f'/Timestep_{current_timestep}/txy'][:])
        tyy_i = np.squeeze(hdf5_r[f'/Timestep_{current_timestep}/tyy'][:])
        tyz_i = np.squeeze(hdf5_r[f'/Timestep_{current_timestep}/tyz'][:])
        tzx_i = np.squeeze(hdf5_r[f'/Timestep_{current_timestep}/tzx'][:])
        tzz_i = np.squeeze(hdf5_r[f'/Timestep_{current_timestep}/tzz'][:])

    # Importing field file data
    field_file_path_location = (f'{SHOCK_DATA_PATH}/field_hdf5/T.{current_timestep}'
                                f'/fields_{current_timestep}.h5')
    with h5py.File(field_file_path_location, 'r') as hdf5_r:
        cex = np.squeeze(hdf5_r[f'/Timestep_{current_timestep}/ex'][:])
        cey = np.squeeze(hdf5_r[f'/Timestep_{current_timestep}/ey'][:])
        cez = np.squeeze(hdf5_r[f'/Timestep_{current_timestep}/ez'][:])
        cbx = np.squeeze(hdf5_r[f'/Timestep_{current_timestep}/cbx'][:])
        cby = np.squeeze(hdf5_r[f'/Timestep_{current_timestep}/cby'][:])
        cbz = np.squeeze(hdf5_r[f'/Timestep_{current_timestep}/cbz'][:])

    hdf5_data_set = {
        't'     : current_timestep,

        'jx_e'  : jx_e,
        'jy_e'  : jy_e,
        'jz_e'  : jz_e,
        'ke_e'  : ke_e,
        'px_e'  : px_e,
        'py_e'  : py_e,
        'pz_e'  : pz_e,
        'rho_e' : rho_e,
        'txx_e' : txx_e,
        'txy_e' : txy_e,
        'tyy_e' : tyy_e,
        'tyz_e' : tyz_e,
        'tzx_e' : tzx_e,
        'tzz_e' : tzz_e,

        'jx_i'  : jx_i,
        'jy_i'  : jy_i,
        'jz_i'  : jz_i,
        'ke_i'  : ke_i,
        'px_i'  : px_i,
        'py_i'  : py_i,
        'pz_i'  : pz_i,
        'rho_i' : rho_i,
        'txx_i' : txx_i,
        'txy_i' : txy_i,
        'tyy_i' : tyy_i,
        'tyz_i' : tyz_i,
        'tzx_i' : tzx_i,
        'tzz_i' : tzz_i,

        'cex'   : cex,
        'cey'   : cey,
        'cez'   : cez,
        'cbx'   : cbx,
        'cby'   : cby,
        'cbz'   : cbz,
    }

    return hdf5_data_set

────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────





────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────

═══════ C:/DEV/local_repo/vpic_python/code_python/scripts/preprocessing/custom_advanced_functions.py ═══════

import numpy as np

def cross_product(a:list[np.ndarray], b:list[np.ndarray], component:str=""):
    """
    args:
        a: [ax, ay, az]
        b: [bx, by, bz]
        *component: return in component form: 'x', 'y', 'z'
    """
    ax, ay, az, bx, by, bz = a[0], a[1], a[2], b[0], b[1], b[2]

    if component == "x":
        return ay * bz - az * by
    elif component == "y":
        return az * bx - ax * bz
    elif component == "z":
        return ax * by - ay * bx

    cx = ay * bz - az * by
    cy = az * bx - ax * bz
    cz = ax * by - ay * bx
    return np.array([cx, cy, cz])

def partial(arr_2d: np.ndarray, component: str = ""):
    # calculate using centered-grid difference
    # [1:-1, 1:-1]
    dx = 0.1

    if component == "x":
        # A_plus = A(x + dx)
        A_plus = np.roll(arr_2d, -1, axis=0) # (x, z) -> (x+1, z)
        # A_minus = A(x - dx)
        A_minus = np.roll(arr_2d, 1, axis=0) # (x, z)   -> (x-1, z)

        # Centered difference: (A(x+dx) - A(x-dx)) / (2*dx)
        return (A_plus - A_minus) / (2 * dx)

    elif component == "z":
        # A_plus = A(z + dz)
        A_plus = np.roll(arr_2d, -1, axis=1) # (x, z) -> (x, z+1)
        # A_minus = A(z - dz)
        A_minus = np.roll(arr_2d, 1, axis=1) # (x, z) -> (x, z-1)

        # Centered difference: (A(z+dz) - A(z-dz)) / (2*dz)
        return (A_plus - A_minus) / (2 * dx)  # assuming dz = dx = 0.1

    return np.zeros_like(arr_2d)

    # NOTE: With centered difference, you have errors at BOTH boundaries (first and last elements).
    # If you are still using roll, your valid region becomes :-2 and 1:-1 depending on your trimming needs.
    # For simplicity, if you stick to the :-1 trimming, the centered difference error will still be much smaller.

def lorentz_transformation_tensor(ux:np.ndarray, uy:np.ndarray, uz:np.ndarray):

    # gamma_u = (1-u.u/c^2)^-1/2
    uu = ux ** 2 + uy ** 2 + uz ** 2 # u.u = u^2
    gamma_u = (1 - uu) ** -0.5

    # arbitrary velocity
    m00 = gamma_u
    m11 = 1 + (gamma_u - 1) * ux * ux / uu
    m22 = 1 + (gamma_u - 1) * uy * uy / uu
    m33 = 1 + (gamma_u - 1) * uz * uz / uu
    m01 = -gamma_u * ux
    m02 = -gamma_u * uy
    m03 = -gamma_u * uz
    m12 = (gamma_u - 1) * ux * uy / uu
    m13 = (gamma_u - 1) * uy * uz / uu
    m23 = (gamma_u - 1) * uy * uz / uu

    # symmetric matrix: M = M.transpose()
    # array.shape(4,4,8192,1024)
    return np.array([
        [m00, m01, m02, m03],
        [m01, m11, m12, m13],
        [m02, m12, m22, m23],
        [m03, m13, m23, m33],
    ])

────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────





────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────

═══════ C:/DEV/local_repo/vpic_python/code_python/scripts/mainloop/main.py ═══════

from rich.progress import Progress # Show run pregress
from code_python.scripts.config.parameters import *
from code_python.scripts.setup.calculation_setup import *
from code_python.scripts.setup.plotting_setup import *
from code_python.scripts.preprocessing.get_hdf5_data import folders, folder_count, read_timestep
from code_python.scripts.preprocessing.plotting_functions import PlotFlowFigure
import code_python.scripts.preprocessing.shock_speed_calculation as shock_speed_calculation
from code_python.scripts.preprocessing.custom_advanced_functions import *
import code_python.scripts.dumping_backup_python_output as backup

DATE_START = backup.datetime.now()

backup.dump_process("▀▄▀▄▀▄ MAINLOOP ▀▄▀▄▀▄")
with (Progress() as progress):
    task = progress.add_task(f"[white] processing...", total=folder_count)
    for folder_index, folder_name in enumerate(folders):
        data = read_timestep(shock_folder=folder_name)

        current_timestep = data['t']

        jx_e             = data['jx_e']
        jy_e             = data['jy_e']
        jz_e             = data['jz_e']
        ke_e             = data['ke_e']
        px_e             = data['px_e']
        py_e             = data['py_e']
        pz_e             = data['pz_e']
        rho_e            = data['rho_e']
        txx_e            = data['txx_e']
        txy_e            = data['txy_e']
        tyy_e            = data['tyy_e']
        tyz_e            = data['tyz_e']
        tzx_e            = data['tzx_e']
        tzz_e            = data['tzz_e']

        jx_i             = data['jx_i']
        jy_i             = data['jy_i']
        jz_i             = data['jz_i']
        ke_i             = data['ke_i']
        px_i             = data['px_i']
        py_i             = data['py_i']
        pz_i             = data['pz_i']
        rho_i            = data['rho_i']
        txx_i            = data['txx_i']
        txy_i            = data['txy_i']
        tyy_i            = data['tyy_i']
        tyz_i            = data['tyz_i']
        tzx_i            = data['tzx_i']
        tzz_i            = data['tzz_i']

        cex              = data['cex']
        cey              = data['cey']
        cez              = data['cez']
        cbx              = data['cbx']
        cby              = data['cby']
        cbz              = data['cbz']

        # ----------------------- CALCULATION PART ----------------------- #
        # Calculating shock speed by tracking time evolution of peak charge density location
        if IS_CALCULATING_SHOCK_SPEED:
            peak_value: float = shock_speed_calculation.get_shock_peak_index(rho_i)
            x_peak: float = peak_value * dx_de  # [length unit]
            t_peak: float = current_timestep * dt_wpe  # [time unit]
            shock_speed_calculation.shock_distances.append(x_peak)
            shock_speed_calculation.shock_times.append(t_peak)

        # Change data to box frame (Lorentz transformation frame)
        if not IS_CALCULATING_LORENTZ_TRANSFORMATION:
            backup.dump_process("(Disabled 'IS_CALCULATING_LORENTZ_TRANSFORMATION')")
        else:
            x0, length = box_frame[0], box_frame[2]
            v = target_velocity
            # Use gamma = 1 / sqrt(1 - v^2), where c = 1 (normalized units)
            gamma = (1 - v ** 2) ** (-1 / 2)
            x_step = int(v * (1 / dx_de) * dt_wpe * current_timestep)
            box_index = [x0 + x_step, (x0 + x_step) + length]
            # Ensure box frame insides simulation frame
            if box_index[0] < 0 or box_index[1] > nx:
                progress.update(task, advance=1)
                backup.dump_process(f"Not calculated Lorentz transformation at T.{current_timestep}: box frame outsides simulation frame.")
                continue

            _jx_e = jx_e[box_index[0]: box_index[1], :]
            _jy_e = jy_e[box_index[0]: box_index[1], :]
            _jz_e = jz_e[box_index[0]: box_index[1], :]
            _ke_e = ke_e[box_index[0]: box_index[1], :]
            _px_e = px_e[box_index[0]: box_index[1], :]
            _py_e = py_e[box_index[0]: box_index[1], :]
            _pz_e = pz_e[box_index[0]: box_index[1], :]
            _rho_e = rho_e[box_index[0]: box_index[1], :]
            _txx_e = txx_e[box_index[0]: box_index[1], :]
            _txy_e = txy_e[box_index[0]: box_index[1], :]
            _tyy_e = tyy_e[box_index[0]: box_index[1], :]
            _tyz_e = tyz_e[box_index[0]: box_index[1], :]
            _tzx_e = tzx_e[box_index[0]: box_index[1], :]
            _tzz_e = tzz_e[box_index[0]: box_index[1], :]

            _jx_i = jx_i[box_index[0]: box_index[1], :]
            _jy_i = jy_i[box_index[0]: box_index[1], :]
            _jz_i = jz_i[box_index[0]: box_index[1], :]
            _ke_i = ke_i[box_index[0]: box_index[1], :]
            _px_i = px_i[box_index[0]: box_index[1], :]
            _py_i = py_i[box_index[0]: box_index[1], :]
            _pz_i = pz_i[box_index[0]: box_index[1], :]
            _rho_i = rho_i[box_index[0]: box_index[1], :]
            _txx_i = txx_i[box_index[0]: box_index[1], :]
            _txy_i = txy_i[box_index[0]: box_index[1], :]
            _tyy_i = tyy_i[box_index[0]: box_index[1], :]
            _tyz_i = tyz_i[box_index[0]: box_index[1], :]
            _tzx_i = tzx_i[box_index[0]: box_index[1], :]
            _tzz_i = tzz_i[box_index[0]: box_index[1], :]

            _cex = cex[box_index[0]: box_index[1], :]
            _cey = cey[box_index[0]: box_index[1], :]
            _cez = cez[box_index[0]: box_index[1], :]
            _cbx = cbx[box_index[0]: box_index[1], :]
            _cby = cby[box_index[0]: box_index[1], :]
            _cbz = cbz[box_index[0]: box_index[1], :]

            # Calculate Lorentz transformation (+x direction)
            rho_i_prime = gamma * (_rho_i - v * _jx_i)
            jx_i_prime = gamma * (_jx_i - _rho_i * v)
            jy_i_prime = _jy_i
            jz_i_prime = _jz_i

            rho_e_prime = gamma * (_rho_e - v * _jx_e)
            jx_e_prime = gamma * (_jx_e - _rho_e * v)
            jy_e_prime = _jy_e
            jz_e_prime = _jz_e

            cex_prime = gamma * _cex - gamma * gamma * v / (gamma + 1) * (v * _cex)
            cey_prime = gamma * (_cey - v * _cbz)
            cez_prime = gamma * (_cez + v * _cby)

            cbx_prime = gamma * _cbx - gamma * gamma * v / (gamma + 1) * (v * _cbx)
            cby_prime = gamma * (_cby + v * _cez)
            cbz_prime = gamma * (_cbz - v * _cey)

        if not ENABLE_ADVANCED_CALCULATION:
            backup.dump_process("(Disabled 'ENABLE_ADVANCED_CALCULATION')")
        else:
            # TODO: doing derived calculation
            ...
            backup.dump_process(f"[{folder_index+1}] Finish calculation T.{current_timestep}")
        # ----------------------------------------------------------------- #

        # ------------------------- PLOTTING PART -------------------------
        """
        Enable built-in features:
        - PlotFlowFigure(timestep, data, vbar, cmap, units)
        available unit: de, di, wpe, wci
        prompt example: units = "de wpe" or "wpe de"

        Example usage:
            fig = PlotFlowFigure(current_timestep, data=rho_i, vbar=(0, 6), cmap=wtdr, units="di wci")
            fig.show_lorentz_frame() # show outline of box frame
            fig.save(filename="rho_i") # or fig.show()
        
        """
        fig1 = PlotFlowFigure(current_timestep, data=rho_i, vbar=(0, 6), cmap=wtdr, units="di wci")
        fig1.show_lorentz_frame(line_reference_ratio=0.5)
        fig1.draw_line_peak_position()
        fig1.save("rho_i")

        # ----------------------------------------------------------------- #
backup.dump_process("▀▄▀▄▀▄ ENDLOOP ▀▄▀▄▀▄")

if IS_CALCULATING_SHOCK_SPEED:
    shock_speed_calculation.show_graph_of_shock_speed_tracking()

if not IS_EXPORT_DATA_TO_CSV:
    backup.dump_process("(Disabled 'IS_EXPORT_DATA_TO_CSV')")
else:
    # TODO: For export data
    ...

backup.save(DATE_START)

────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────





────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Process Log:

folder count = 1
▀▄▀▄▀▄ MAINLOOP ▀▄▀▄▀▄
[1] Finish calculation T.64584
Saved C:/DEV/local_repo/vpic_python/code_python/figures/rho_i.png
▀▄▀▄▀▄ ENDLOOP ▀▄▀▄▀▄